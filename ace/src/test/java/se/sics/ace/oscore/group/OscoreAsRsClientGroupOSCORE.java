package se.sics.ace.oscore.group;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.security.PrivateKey;
import java.security.Provider;
import java.security.SecureRandom;
import java.security.Security;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;

import org.bouncycastle.crypto.InvalidCipherTextException;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.eclipse.californium.core.CoapClient;
import org.eclipse.californium.core.CoapResponse;
import org.eclipse.californium.core.coap.CoAP;
import org.eclipse.californium.core.coap.MediaTypeRegistry;
import org.eclipse.californium.core.coap.Request;
import org.eclipse.californium.core.coap.Response;
import org.eclipse.californium.core.coap.CoAP.Code;
import org.eclipse.californium.core.coap.CoAP.Type;
import COSE.AlgorithmID;
import COSE.CoseException;
import COSE.KeyKeys;
import COSE.MessageTag;
import COSE.OneKey;
import net.i2p.crypto.eddsa.EdDSASecurityProvider;

import org.eclipse.californium.elements.exception.ConnectorException;
import org.eclipse.californium.oscore.OSException;
import org.junit.Assert;

import com.upokecenter.cbor.CBORObject;

import se.sics.ace.AceException;
import se.sics.ace.COSEparams;
import se.sics.ace.Constants;
import se.sics.ace.coap.client.OSCOREProfileRequests;
import se.sics.ace.coap.client.OSCOREProfileRequestsGroupOSCORE;
import se.sics.ace.coap.rs.oscoreProfile.OscoreCtxDbSingleton;
import se.sics.ace.cwt.CWT;
import se.sics.ace.cwt.CwtCryptoCtx;
import se.sics.ace.oscore.GroupOSCORESecurityContextObject;
import se.sics.ace.oscore.OSCORESecurityContextObjectParameters;

/**
 * FIXME: Needs updating after import of master code
 * 
 * A stand-alone application for Client->AS followed by Client->GM communication
 * using the OSCORE profile.
 * 
 * First the client will request a Token from the AS, it will then post it to
 * the GM and then proceed with the Group Joining procedure.
 * 
 * @author Rikard HÃ¶glund
 *
 */
public class OscoreAsRsClientGroupOSCORE {

	/**
	 * Main method
	 */
	public static void main(String[] args) {
        try {
            postTokenAndJoin();
        } catch (IllegalStateException | InvalidCipherTextException | CoseException | AceException | OSException
                | ConnectorException | IOException e) {
            System.err.print("Join procedure failed: ");
            e.printStackTrace();
        }
    }
	
	// M.T. & Rikard
    /**
	 * Post to Authz-Info, then perform join request using multiple roles. Uses
	 * the ACE OSCORE Profile.
	 * 
	 * @throws AceException if ACE processing fails
	 * @throws CoseException if COSE processing fails
	 * @throws InvalidCipherTextException if cipher processing fails
	 * @throws IllegalStateException on failure
	 * @throws OSException if OSCORE processing fails
	 * @throws IOException on failure
	 * @throws ConnectorException if connection fails
	 */
    public static void postTokenAndJoin() throws IllegalStateException, InvalidCipherTextException, CoseException, AceException, OSException, ConnectorException, IOException {

        /* Configure parameters for the join request */

        boolean askForSignInfo = true;
        boolean askForPubKeyEnc = true;
        boolean askForPubKeys = true;
        boolean providePublicKey = true;

        // Generate private and public key to be used in the OSCORE group by the joining client (EDDSA)
		// Install needed cryptography providers
		Provider PROVIDER = new BouncyCastleProvider();
		Provider EdDSA = new EdDSASecurityProvider();
		Security.insertProviderAt(PROVIDER, 1);
		Security.insertProviderAt(EdDSA, 0);

		String groupKeyPair = getCounterSignKey(); // "pQMnAQEgBiFYIAaekSuDljrMWUG2NUaGfewQbluQUfLuFPO8XMlhrNQ6I1ggZHFNQaJAth2NgjUCcXqwiMn0r2/JhEVT5K1MQsxzUjk=";

        // Set EDDSA with curve Ed25519 for countersignatures
        int countersignKeyCurve = KeyKeys.OKP_Ed25519.AsInt32();

        // The cnf key used in these tests
        byte[] keyCnf = {'a', 'b', 'c', 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};

        //The AS <-> RS key used in these tests
        byte[] keyASRS = {'c', 'b', 'c', 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};
        
        String groupName = "feedca570000";
        String audience = "rs2";
        String asName = "TestAS";
        String clientID = "clientD";
        String cti = "token4JoinMultipleRolesDeriv" + clientID;

        String gmBaseURI = "coap://localhost/";
        String authzInfoURI = gmBaseURI + "authz-info";
        String joinResourceURI = gmBaseURI + groupName;

        System.out.println("Performing Token post to GM followed by Join request.");
        System.out.println("GM join resource is at: " + joinResourceURI);

        /* Prepare ACE Token generated by the client */

        //Generate a token (update to get Token from AS here instead)
        COSEparams coseP = new COSEparams(MessageTag.Encrypt0, AlgorithmID.AES_CCM_16_128_128, AlgorithmID.Direct);
        CwtCryptoCtx ctx = CwtCryptoCtx.encrypt0(keyASRS, coseP.getAlg().AsCBOR());
        Map<Short, CBORObject> params = new HashMap<>(); 

        //Create a byte string scope for use later
        String gid = new String(groupName);
        String role1 = new String("requester");
        String role2 = new String("responder");

        CBORObject cborArrayScope = CBORObject.NewArray();
        cborArrayScope.Add(gid);
        CBORObject cborArrayRoles = CBORObject.NewArray();
        cborArrayRoles.Add(role1);
        cborArrayRoles.Add(role2);
        cborArrayScope.Add(cborArrayRoles);
        byte[] byteStringScope = cborArrayScope.EncodeToBytes();

        params.put(Constants.SCOPE, CBORObject.FromObject(byteStringScope));
        params.put(Constants.AUD, CBORObject.FromObject(audience));
        params.put(Constants.CTI, CBORObject.FromObject(cti.getBytes(Constants.charset))); //Need different CTIs
        params.put(Constants.ISS, CBORObject.FromObject(asName));

        CBORObject osc = CBORObject.NewMap();
        byte[] clientId = clientID.getBytes(Constants.charset); //Need different client IDs
        osc.Add(Constants.OS_CLIENTID, clientId);
        osc.Add(Constants.OS_MS, keyCnf);
        byte[] serverId = audience.getBytes(Constants.charset);
        osc.Add(Constants.OS_SERVERID, serverId);

        CBORObject cnf = CBORObject.NewMap();
        cnf.Add(Constants.OSCORE_Security_Context, osc);
        params.put(Constants.CNF, cnf);
        CWT token = new CWT(params);
        CBORObject payload = CBORObject.NewMap();
        payload.Add(Constants.ACCESS_TOKEN, token.encode(ctx));
        payload.Add(Constants.CNF, cnf);
        Response asRes = new Response(CoAP.ResponseCode.CREATED);
        asRes.setPayload(payload.EncodeToBytes());

        /* Post Token to GM */

        System.out.println("Performing Token request to GM. Assuming response from AS was: " + payload.toString());

        Response rsRes = OSCOREProfileRequestsGroupOSCORE.postToken(authzInfoURI, asRes, askForSignInfo, askForPubKeyEnc);

        /* Check response from GM to Token post */

        assert(rsRes.getCode().equals(CoAP.ResponseCode.CREATED));
        //Check that the OSCORE context has been created:
        Assert.assertNotNull(OscoreCtxDbSingleton.getInstance().getContext(joinResourceURI));

        CBORObject rsPayload = CBORObject.DecodeFromBytes(rsRes.getPayload());

        System.out.println("Receved response from GM to Token post: " + rsPayload.toString());

        // Sanity checks already occurred in OSCOREProfileRequestsGroupOSCORE.postToken()

        // Nonce from the GM, to be signed together with a local nonce to prove PoP of the private key
		byte[] gm_sign_nonce = rsPayload.get(CBORObject.FromObject(Constants.KDCCHALLENGE)).GetByteString();

        @SuppressWarnings("unused")
        CBORObject signInfo = null;
        @SuppressWarnings("unused")
        CBORObject pubKeyEnc = null;

        if (askForSignInfo) {
            signInfo = rsPayload.get(CBORObject.FromObject(Constants.SIGN_INFO));
        }

        if (askForPubKeyEnc) {
            pubKeyEnc = rsPayload.get(CBORObject.FromObject(Constants.PUB_KEY_ENC));
        }

        /* Now proceed to build join request to GM */

        CoapClient c = OSCOREProfileRequests.getClient(new InetSocketAddress(joinResourceURI, CoAP.DEFAULT_COAP_PORT));

        CBORObject requestPayload = CBORObject.NewMap();

        requestPayload.Add(Constants.SCOPE, CBORObject.FromObject(byteStringScope));

        if (askForPubKeys) {
            CBORObject getPubKeys = CBORObject.NewArray();
            requestPayload.Add(Constants.GET_PUB_KEYS, getPubKeys);
        }

        if (providePublicKey) {

            // For the time being, the client's public key can be only a COSE Key
            OneKey publicKey = new OneKey(CBORObject.DecodeFromBytes(Base64.getDecoder().decode(groupKeyPair))).PublicKey();

            requestPayload.Add(Constants.CLIENT_CRED, publicKey.AsCBOR().EncodeToBytes());

            // Add the nonce for PoP of the Client's private key
            byte[] cnonce = new byte[8];
            new SecureRandom().nextBytes(cnonce);
            requestPayload.Add(Constants.CNONCE, cnonce);

            // Add the signature computed over (rsnonce | cnonce), using the Client's private key
            PrivateKey privKey = (new OneKey(CBORObject.DecodeFromBytes(Base64.getDecoder().decode(groupKeyPair)))).AsPrivateKey();
            byte [] dataToSign = new byte [gm_sign_nonce.length + cnonce.length];
            System.arraycopy(gm_sign_nonce, 0, dataToSign, 0, gm_sign_nonce.length);
            System.arraycopy(cnonce, 0, dataToSign, gm_sign_nonce.length, cnonce.length);

            byte[] clientSignature = OscorepClient2RSGroupOSCORE.computeSignature(privKey, dataToSign, countersignKeyCurve);

            if (clientSignature != null)
                requestPayload.Add(Constants.CLIENT_CRED_VERIFY, clientSignature);
            else
                Assert.fail("Computed signature is empty");

        }

        Request joinReq = new Request(Code.POST, Type.CON);
        joinReq.getOptions().setOscore(new byte[0]);
        joinReq.setPayload(requestPayload.EncodeToBytes());
        joinReq.getOptions().setContentFormat(MediaTypeRegistry.APPLICATION_CBOR);

        /* Send to join request to GM */

        System.out.println("Performing Join request to GM: " + requestPayload.toString());
        CoapResponse r2 = c.advanced(joinReq);

        /* Parse response to Join request from GM */

        byte[] responsePayload = r2.getPayload();
        CBORObject joinResponse = CBORObject.DecodeFromBytes(responsePayload);


        //The following three lines were useful for generating the Group OSCORE context
        //CBORObject keyMap = joinResponse.get(CBORObject.FromObject(Constants.KEY));
		//Map<Short, CBORObject> contextParams = new HashMap<>(OSCORESecurityContextObjectParameters.getParams(keyMap));
        //GroupOSCORESecurityContextObject contextObject = new GroupOSCORESecurityContextObject(contextParams); 

        System.out.println("Receved response from GM to Join request: " + joinResponse.toString());

        /* Parse the Join response in detail */

        OscorepClient2RSGroupOSCORE.printJoinResponse(joinResponse);

        /* Generate a Group OSCORE security context from the Join response */

		// Add checking of the derived context
		TestDtlspClientGroupOSCORE.groupOSCOREContextDeriver(joinResponse);

    }

	public static String getCounterSignKey() throws CoseException {
		OneKey myKey = OneKey.generateKey(AlgorithmID.EDDSA);
		byte[] keyObjectBytes = myKey.AsCBOR().EncodeToBytes();
		String base64_encoded = Base64.getEncoder().encodeToString(keyObjectBytes);
		return base64_encoded;
	}
}
